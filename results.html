<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>ChatGPT Usage Results</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" href="./assets/app.css" />
</head>
<body>
  <header class="container">
    <h1>ChatGPT Usage Results</h1>
    <p class="muted" id="fileMeta">Analyzing…</p>
  </header>

  <main class="container">
    <section class="card">
      <div id="status" class="status">Downloading JSON…</div>

      <div id="results" class="grid two" hidden>
        <div class="stat">
          <div class="label">Total Hours</div>
          <div class="value" id="hours">—</div>
        </div>
        <div class="stat">
          <div class="label">Sessions</div>
          <div class="value" id="sessions">—</div>
        </div>
      </div>

      <div id="timeframe" class="meta" hidden>
        <div><strong>First activity:</strong> <span id="firstTs">—</span></div>
        <div><strong>Last activity:</strong> <span id="lastTs">—</span></div>
        <div class="muted">Gap rule: <span id="gapRule">30</span> minutes</div>
      </div>

      <!-- Error preview if parsing or network fails -->
      <div id="errorBox" class="card subtle" hidden>
        <div class="label">Error details</div>
        <pre id="errorJson"></pre>
      </div>

      <div id="raw" class="code card subtle" hidden>
        <div class="label">Debug output</div>
        <pre id="rawJson"></pre>
      </div>

      <div class="actions">
        <a class="btn" href="./index.html">Upload another file</a>
        <button class="btn ghost" id="toggleRaw">Show debug</button>
        <button class="btn" id="downloadReport" hidden>Download Report</button>
        <!-- Fallback controls -->
        <input type="file" id="fileInput" accept=".json,application/json" hidden />
        <button class="btn" id="chooseLocal" hidden>Choose JSON file instead</button>
        <a class="btn ghost" id="openUrl" href="#" target="_blank" hidden>Open file URL</a>
      </div>
    </section>
  </main>

  <footer class="container footnote">
    Computed locally in your browser. Uses a 30-minute session gap.
  </footer>

  <script>
    // ====== Config ======
    const DEFAULT_GAP_MINUTES = 30;

    // ====== UI helpers ======
    const qs = new URLSearchParams(location.search);
    const fileUrl = qs.get('fileUrl');
    const name = qs.get('name') || 'uploaded.json';
    const $ = (id) => document.getElementById(id);

    $('fileMeta').textContent = `File: ${name}`;
    $('gapRule').textContent = String(DEFAULT_GAP_MINUTES);

    $('toggleRaw').addEventListener('click', () => {
      const raw = $('raw');
      raw.hidden = !raw.hidden;
      $('toggleRaw').textContent = raw.hidden ? 'Show debug' : 'Hide debug';
    });

    // Fallback controls
    const fileInput = $('fileInput');
    const chooseLocalBtn = $('chooseLocal');
    const openUrlBtn = $('openUrl');

    chooseLocalBtn.addEventListener('click', () => fileInput.click());
    fileInput.addEventListener('change', async () => {
      if (fileInput.files && fileInput.files[0]) {
        $('status').textContent = 'Reading local file…';
        const text = await fileInput.files[0].text();
        processText(text, `(local) ${fileInput.files[0].name}`);
      }
    });

    if (fileUrl) {
      openUrlBtn.href = fileUrl;
      openUrlBtn.hidden = false; // quick way to try in a new tab if fetch fails
    }

    let reportData = null;

    // ====== Core: try remote fetch first ======
    (async () => {
      const statusEl = $('status');
      if (!fileUrl) {
        statusEl.textContent = 'Missing fileUrl in query string.';
        showFallback();
        return;
      }

      try {
        statusEl.textContent = 'Downloading JSON from Uploadcare…';
        const res = await fetch(withInlineHint(fileUrl), {
          mode: 'cors',
          credentials: 'omit',
          cache: 'no-store'
        });

        if (!res.ok) {
          const txt = await safeText(res);
          onFetchFail(res.status, txt);
          return;
        }

        const text = await res.text();
        $('rawJson').textContent = `Downloaded length: ${text.length}`;
        processText(text, name);

      } catch (e) {
        onFetchFail('network', String(e && e.message || e));
      }
    })();

    // Try adding inline hint (helps in some CDN configs)
    function withInlineHint(url) {
      try {
        const u = new URL(url);
        // Ensure trailing slash for op paths, then try "-/inline/yes/"
        if (!u.pathname.endsWith('/')) u.pathname += '/';
        return `${u.origin}${u.pathname}-/inline/yes/${u.search}`;
      } catch { return url; }
    }

    async function safeText(res) {
      try { return await res.text(); } catch { return ''; }
    }

    function onFetchFail(status, preview) {
      $('errorBox').hidden = false;
      $('errorJson').textContent = JSON.stringify({
        error: 'Failed to fetch',
        status,
        preview: typeof preview === 'string' ? preview.slice(0, 200) : String(preview)
      }, null, 2);
      $('status').textContent = 'Download failed. You can choose the JSON locally instead.';
      showFallback();
    }

    function showFallback() {
      $('chooseLocal').hidden = false;
      $('openUrl').hidden = !fileUrl;
    }

    // ====== Process text (JSON/NDJSON) and render ======
    function processText(text, displayName) {
      let data;
      try {
        data = JSON.parse(text);
      } catch {
        try {
          data = text.trim().split(/\r?\n/).map(line => JSON.parse(line));
        } catch {
          $('errorBox').hidden = false;
          $('errorJson').textContent = JSON.stringify({
            error: 'Not valid JSON or NDJSON',
            preview: text.slice(0,200),
            length: text.length
          }, null, 2);
          $('status').textContent = 'Parsing failed.';
          $('raw').hidden = false;
          return;
        }
      }

      $('status').textContent = 'Extracting timestamps…';
      const stamps = extractTimestamps(data);
      if (!stamps.length) {
        $('status').textContent = 'No timestamps found in file.';
        $('errorBox').hidden = false;
        $('errorJson').textContent = JSON.stringify({ note: 'No timestamps found. Check your export file.' }, null, 2);
        return;
      }

      $('status').textContent = 'Calculating sessions…';
      const result = calcSessions(stamps, DEFAULT_GAP_MINUTES);

      $('hours').textContent = result.totalHours.toFixed(2);
      $('sessions').textContent = String(result.sessions);
      $('firstTs').textContent = result.first ? new Date(result.first).toLocaleString() : '—';
      $('lastTs').textContent  = result.last  ? new Date(result.last ).toLocaleString() : '—';

      $('results').hidden = false;
      $('timeframe').hidden = false;
      $('status').textContent = 'Done.';

      reportData = {
        file: displayName,
        totalHours: result.totalHours.toFixed(2),
        sessions: result.sessions,
        first: result.first ? new Date(result.first).toISOString() : null,
        last:  result.last  ? new Date(result.last ).toISOString() : null,
        gapMinutes: DEFAULT_GAP_MINUTES,
        events: result.events
      };
      $('downloadReport').hidden = false;
    }

    // ====== Download a plain-text report ======
    document.getElementById('downloadReport').addEventListener('click', () => {
      if (!reportData) return;
      const t = `ChatGPT Usage Report

File: ${reportData.file}
Total Hours: ${reportData.totalHours}
Sessions: ${reportData.sessions}
First: ${reportData.first ?? '—'}
Last: ${reportData.last ?? '—'}
Events parsed: ${reportData.events}
Gap minutes: ${reportData.gapMinutes}
Generated: ${new Date().toISOString()}
`;
      const blob = new Blob([t], { type: 'text/plain' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'chatgpt_usage_report.txt';
      a.click();
      URL.revokeObjectURL(url);
    });

    // ====== Timestamp extraction & session math ======
    const TIMESTAMP_KEYS = new Set([
      'create_time','created','created_at','timestamp','ts',
      'time','date','update_time','modified_at','last_activity_time'
    ]);

    function extractTimestamps(any) {
      const out = new Set();

      function toDate(v){
        if (v == null) return null;
        if (typeof v === 'number') {
          if (v > 1e12) return new Date(v);        // ms
          if (v > 1e9)  return new Date(v*1000);   // s
          return null;
        }
        if (typeof v === 'string') {
          if (/^\d{10,13}(\.\d+)?$/.test(v)) {
            const n = Number(v);
            if (n > 1e12) return new Date(n);
            if (n > 1e9)  return new Date(n*1000);
          }
          const d = new Date(v);
          return isNaN(d) ? null : d;
        }
        return null;
      }

      (function visit(n){
        if (!n) return;
        if (Array.isArray(n)) return n.forEach(visit);
        if (typeof n === 'object') {
          for (const [k, v] of Object.entries(n)) {
            const lk = k.toLowerCase();
            if (TIMESTAMP_KEYS.has(lk)) {
              const d = toDate(v);
              if (d) out.add(d.toISOString());
            }
            if (v && typeof v === 'object') visit(v);
          }
        }
      })(any);

      return Array.from(out).map(s => new Date(s)).sort((a,b)=>a-b);
    }

    function calcSessions(timestamps, gapMinutes = 30) {
      const gapMs = gapMinutes * 60 * 1000;
      if (!timestamps.length) return { totalHours: 0, sessions: 0, events: 0, first: null, last: null };

      let sessions = 0, totalMs = 0;
      let first = timestamps[0], last = timestamps[0];
      let start = timestamps[0], prev = timestamps[0];

      for (let i = 1; i < timestamps.length; i++) {
        const t = timestamps[i];
        if (t - prev >= gapMs) {
          sessions++;
          totalMs += Math.max(prev - start, 60 * 1000); // min 1 minute
          start = t;
        }
        prev = t;
        last = t;
      }
      sessions++;
      totalMs += Math.max(last - start, 60 * 1000);

      return {
        totalHours: totalMs / 3_600_000,
        sessions,
        events: timestamps.length,
        first,
        last
      };
    }
  </script>
</body>
</html>
